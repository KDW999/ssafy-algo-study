> https://www.acmicpc.net/problem/9663
> 
> 백트래킹 :
>
> 모든 경우의 수를 고려하여 상태 공간 트리로 나타낼 수 있을 때
> 
> 조건에 맞지 않으면 즉시 중단하고 돌아가면서 원하는 조건을 찾는 알고리즘
>
1. 퀸은 가로, 세로, 대각선에 있는 말을 공격할 수 있음
2. 퀸이 놓일 수 있는 모든 경우의 수를 dfs로 탐색
 
    2-1. 한 행에는 한 개의 퀸만 놓을 수 있다고 가정
  
    2-2. for문으로 특정 행의 특정 열에 퀸을 놓고 : col[row] = c
  
    2-3. 다음 행으로 재귀

3. 기저 조건, 가지 치기로 적절히 return

    3-1. 기저 : 행이 N 이상이면 체스판 끝 행까지 간 것이므로 경우의 수(ans) 카운트 후 return
  
    3-2. 가지치기 : 이전 행까지 놓인 퀸들이 유효하지 않으면 return

4. 체스판 유효 판단 메소드

    4-1. 1부터 row-1까지 탐색(i)
  
    4-2. col[i]값과 col[row]값이 같은 경우 : 같은 열이므로 퀸이 있을 수 없음
  
    4-3. 행 차이 값과 열 차이 값이 같은 경우 : 같은 대각선이므로 퀸이 있을 수 없음
  
   -> 유효하지 않음
  
    4-4. 이외에는 유효 (2-1 가정으로 행 조건은 없음)

```java
import java.util.Scanner;
public class Main {
	
	static int N, col[], ans;
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		N = sc.nextInt();
		col = new int[N+1];
		ans = 0; 
		
		setQueen(1);
		System.out.println(ans); 
	}

	private static void setQueen(int row) { 
		if(!isAvailable(row-1)) return; //이전 행까지 놓인 퀸들이 유효한지
		
		//기저
		if(row>N) { 
			ans++;
			return;
		}
		
		//유도
		for(int c=1; c<=N ; c++) { 
			col[row] = c; 
			setQueen(row+1); 
		}
	}
	private static boolean isAvailable(int row) { 
		for(int i=1;i<row;i++) {
			if(col[i] == col[row] || row-i == Math.abs(col[row] - col[i])) 
				return false;
		}
		return true;	
	}
}
